

## 探究计算机启动过程

**作用解析**

Disk （磁盘）: 存放OS（操作系统）和BootLoader

BOIS : 基于I/O处理系统

Bootloader : 加载OS，将OS放入内存

**结构**

Disk

   |----OS

   |----Bootloader

**开机流程**

1.  BIOS
    *   开机后，寻找显卡和执行BIOS (此时, `CS : IP = 0xF000 : 0xFFF0`,  CS/IP 两个寄存器) 
    *   将Bootloader从磁盘的引导扇区加载到0x7C00 (Bootloader一共占用512M字节的内存)
    *   跳转到 `CS : IP = 0x0000 : 0x7C00`

2.  Bootloader
    *   将操作系统的代码和数据从硬盘加载到内存中
    *   跳转到操作系统的起始地址

## 中断、异常、系统调用

### 中断、异常和系统调用工作关系图

![](imgs/%E5%B7%A5%E4%BD%9C%E5%85%B3%E7%B3%BB%E5%9B%BE.png)

### 中断

中断来源于**外设**，来自不同的硬件设备的计时器和网络的中断。

**中断流程**

硬件：设置中断标记（CPU初始化）

1.  将内部、外部事件设置中断标记
2.  中断事件的ID

软件

1.  保存当前处理状态（寄存器之类的一些数据）
2.  根据中断事件的ID跳转到中断服务程序（例如中断向量表），中断服务程序处理
3.  清除中断标记

#### 中断嵌套

同一时间出现多个中断的处理机制，如：

- 出现新中断，如果其优先级高于当前中断，则会优先执行
- 如果当前中断很重要，比如电池没电，则会拒绝其他任何中断

### 异常

异常来源于**不良的应用程序**，非法指令或者其他坏的处理状态（如：内存出错）。

**异常处理流程**

1.  保存现场
2.  异常处理
    1.  杀死了产生异常的程序
    2.  重新执行异常指令
3.  恢复现场

### 系统调用

系统调用来源于**应用程序**，**应用程序主动向操作系统发出服务请求**。程序访问主要是通过高层次的API，而不是直接调用系统调用函数。

**特点**

-   通常情况下，每个系统调用有对应的序号
    -   系统调用接口根据这些序号来维护表的索引
-   系统调用接口调用内核态中预期的系统调用
    -   并返回系统调用的状态和其他任何返回值
-   用户不需要知道系统调用是如何实现的
    -   只需要获取API和了解操作系统将什么作为返回结果
    -   操作系统接口的细节大部分都隐藏在API中

**用户态**：不能直接执行特权指令

**内核态**：可以执行任何一条指令

**系统调用**：触发CPU从用户态到内核态的转换，切换程序和内核的堆栈，需要一定的开销

**跨越操作系统边界的开销（值得的且必须的，保证了操作系统的安全性）**

-   在执行时间上的开销超过程序调用
-   开销：
    -   建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销
    -   建立内核堆栈
    -   验证参数
    -   内核态映射到用户态的地址空间（更新页面映射权限）
    -   内核态独立地址空间（TLB）

### 三者的区别

| 类型     | 源头                     | 响应方式   | 处理方法                   |
| -------- | ------------------------ | ---------- | -------------------------- |
| 中断     | 外设                     | 异步       | 持续，对用户的应用程序透明 |
| 异常     | 应用程序意向不到的行为   | 同步       | 杀死或重新执行指令         |
| 系统调用 | 应用程序请求系统提供服务 | 同步或异步 | 等待和持续                 |

>   异步：应用程序不知道什么时候会发生中断

>   同步：执行到某一条指令一定会发生该事件

### 为什么应用程序不能直接访问硬件？

在计算机运行时，内核是被信任的第三方，只有内核可以执行特权指令，如果任由用户态的程序访问内存等硬件设备，有可能会导致用户的程序修改了本不应修改的数据资源，进一步可能导致系统的崩溃，因此用户态程序不应该能够直接访问硬件。

同时，由于硬件设备之间存在不同形式的接口，操作系统进行统一处理访问硬件的逻辑，这样可以方便应用程序的编写，因此从这个角度看访问硬件也不应由应用程序自己去操作。

